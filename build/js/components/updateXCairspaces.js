import pg from"pg";import axios from"axios";import pgFormat from"pg-format";const{Pool}=pg,pool=new Pool({user:"postgres",host:"localhost",database:"postgres",password:"@Jy58si7812.2025",port:5432});function formatDateForApi(e){return`${e.getFullYear()}-${e.getMonth()+1}-${e.getDate()}`}function formatDateForDb(e){return e.toISOString().split("T")[0]}async function ensureTableExists(){const e=await pool.connect();try{await e.query("\n      CREATE EXTENSION IF NOT EXISTS postgis;\n      \n      CREATE TABLE IF NOT EXISTS xcairspaces (\n        id SERIAL PRIMARY KEY,\n        name TEXT,\n        airspace_class TEXT,\n        check_type TEXT,\n        upper_limit TEXT,\n        lower_limit TEXT,\n        upper_limit_data JSONB,\n        lower_limit_data JSONB,\n        stroke_color TEXT,\n        stroke_weight INTEGER,\n        fill_color TEXT,\n        fill_opacity FLOAT,\n        country_code TEXT,\n        fetch_date DATE,\n        descriptions JSONB,\n        activations JSONB,\n        geometry GEOMETRY(POLYGON, 4326)\n      );\n      \n      CREATE INDEX IF NOT EXISTS xcairspaces_geometry_idx ON xcairspaces USING GIST (geometry);\n      CREATE INDEX IF NOT EXISTS xcairspaces_fetch_date_idx ON xcairspaces (fetch_date);\n\n      -- Add the descriptions column if it doesn't exist\n      DO $$ \n      BEGIN \n        IF NOT EXISTS (\n          SELECT FROM information_schema.columns \n          WHERE table_name = 'xcairspaces' AND column_name = 'descriptions'\n        ) THEN\n          ALTER TABLE xcairspaces ADD COLUMN descriptions JSONB;\n        END IF;\n      END $$;\n      \n      -- Add the activations column if it doesn't exist\n      DO $$ \n      BEGIN \n        IF NOT EXISTS (\n          SELECT FROM information_schema.columns \n          WHERE table_name = 'xcairspaces' AND column_name = 'activations'\n        ) THEN\n          ALTER TABLE xcairspaces ADD COLUMN activations JSONB;\n        END IF;\n      END $$;\n    "),console.log("Table checked/created successfully")}catch(e){throw console.error("Error creating table:",e),e}finally{e.release()}}async function removeOldData(e){const t=await pool.connect();try{const o=await t.query("DELETE FROM xcairspaces WHERE fetch_date < $1",[e]);console.log(`Removed ${o.rowCount} old airspace records`)}catch(e){throw console.error("Error removing old data:",e),e}finally{t.release()}}async function fetchAirspaceData(e,t){try{const o=`https://airspace.xcontest.org/web/country/${e}?start=${t}&restrictlang=1&skip=&aircatpg=1&skip_alerts=1`;return(await axios.get(o)).data}catch(o){return console.error(`Error fetching airspace data for country ${e} on ${t}:`,o.message),null}}async function storeAirspaceData(e,t,o){if(!e||0===e.length)return void console.log(`No features to store for country ${o} on ${t}`);const a=await pool.connect();try{await a.query("DELETE FROM xcairspaces WHERE fetch_date = $1 AND country_code = $2",[t,o.toString()]);for(const r of e){const{properties:e,geometry:n}=r;if(n&&n.coordinates&&0!==n.coordinates.length)if("Polygon"===n.type)try{const r=JSON.stringify(n),s=JSON.stringify(e.descriptions||[]),c=JSON.stringify(e.activations||[]);await a.query("\n          INSERT INTO xcairspaces (\n            name, airspace_class, check_type, upper_limit, lower_limit,\n            upper_limit_data, lower_limit_data, stroke_color, stroke_weight,\n            fill_color, fill_opacity, country_code, fetch_date, descriptions, \n            activations, geometry\n          ) VALUES (\n            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,\n            $15, ST_GeomFromGeoJSON($16)\n          )\n        ",[e.name||"",e.airspaceClass||"",e.airspaceCheckType||"",e.upperLimit||"",e.lowerLimit||"",JSON.stringify(e.airupper_j||{}),JSON.stringify(e.airlower_j||{}),e.strokeColor||"",e.strokeWeight||1,e.fillColor||"",e.fillOpacity||.35,e.foreignisocode||o.toString(),t,s,c,r])}catch(t){console.error(`Error inserting feature "${e?.name}":`,t.message)}else console.warn(`Unsupported geometry type: ${n.type} for feature: ${e?.name}`);else console.warn("Skipping feature with invalid geometry:",e?.name)}console.log(`Stored airspace records for country ${o} on ${t}`)}catch(e){throw console.error(`Error storing airspace data for country ${o} on ${t}:`,e),e}finally{a.release()}}async function fetchAndStoreAirspaces(){try{await ensureTableExists();const e=new Date,t=formatDateForDb(e);await removeOldData(t);for(let t=0;t<6;t++){const o=new Date(e);o.setDate(e.getDate()+t);const a=formatDateForApi(o),r=formatDateForDb(o);console.log(`Fetching data for ${r}`);for(let e=1;e<=50;e++){console.log(`Fetching data for country ${e} on ${r}`);const t=await fetchAirspaceData(e,a);t&&t.features?await storeAirspaceData(t.features,r,e):console.log(`No data returned for country ${e} on ${r}`),await new Promise((e=>setTimeout(e,500)))}}console.log("Airspace data fetch and store operation completed successfully")}catch(e){console.error("Error in fetchAndStoreAirspaces:",e)}finally{await pool.end()}}async function testSingleCountry(e=5){try{await ensureTableExists();const t=new Date,o=formatDateForApi(t),a=formatDateForDb(t);console.log(`Testing fetch for country ${e} on ${a}`);const r=await fetchAirspaceData(e,o);r&&r.features?(console.log(`Fetched ${r.features.length} features`),await storeAirspaceData(r.features,a,e),console.log("Test completed successfully")):console.log("No data returned from API")}catch(e){console.error("Test failed:",e)}finally{await pool.end()}}export{fetchAndStoreAirspaces,ensureTableExists,fetchAirspaceData,storeAirspaceData,testSingleCountry};